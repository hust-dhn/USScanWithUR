from sys_path import *
from api.library_loader import *
from api.errors import Error
from api.inu_sensor import InuSensor, ConnectionState, create_started_sensor, DeviceParams, SensorResolution
from api.shared import StreamType

import os
import numpy as np
import time
import threading
from pynput import keyboard


# ===================== 设备参数 =====================
device_params = DeviceParams()
device_params.fps = 3
device_params.resolution = SensorResolution.BINNING

# ===================== 保存参数（你只需要改这里） =====================
SAVE_DIR = "camera/pc_datas"      # 保存目录
SAVE_PREFIX = ""                  # 文件名前缀，可留空
SAVE_EVERY_N_FRAMES = 1           # 每 N 帧保存一次（=1 表示每帧都存）
MAX_SAVE_FRAMES = 0               # 最多保存多少帧；0 表示不限制
START_INDEX = 0                   # 文件编号起始值（比如接着存就改成已有最大+1）

# 文件名格式：例如 "{prefix}{idx:04d}.ply"
FILENAME_FMT = "{prefix}{idx:04d}.ply"

# 超时重试参数
TIMEOUT_RETRY_SLEEP = 0.05
MAX_CONSECUTIVE_TIMEOUTS = 50     # 连续超时多少次后直接抛错退出
# =====================================================

stop_flag = False
lock = threading.Lock()
last_stride = None


# ===================== PLY 写入：保留所有列 =====================
def _np_dtype_to_ply_type(dt: np.dtype) -> str:
    dt = np.dtype(dt)
    if dt == np.dtype(np.int8):    return "char"
    if dt == np.dtype(np.uint8):   return "uchar"
    if dt == np.dtype(np.int16):   return "short"
    if dt == np.dtype(np.uint16):  return "ushort"
    if dt == np.dtype(np.int32):   return "int"
    if dt == np.dtype(np.uint32):  return "uint"
    if dt == np.dtype(np.float32): return "float"
    if dt == np.dtype(np.float64): return "double"
    return "float"  # 其他类型统一按 float 存（兼容性更好）


def write_ply_binary_all_columns(filename: str, pts2: np.ndarray):
    """
    写二进制 PLY：保留 pts2 的所有列
    - 列0,1,2: x,y,z （强制 float32，兼容性最好）
    - 列3.. : attr3, attr4, ... （尽量保留原 dtype；不支持则转 float32）
    """
    pts2 = np.asarray(pts2)
    if pts2.ndim != 2 or pts2.shape[1] < 3:
        raise ValueError(f"pts2 must be (N,>=3). got {pts2.shape}")

    n, stride = pts2.shape

    col_dtypes = []
    ply_types = []

    for j in range(stride):
        dt0 = pts2[:, j].dtype

        if j < 3:
            # XYZ 一律 float32
            col_dtype = np.dtype("<f4")
            ply_type = "float"
        else:
            ply_type = _np_dtype_to_ply_type(dt0)
            if ply_type == "char":    col_dtype = np.dtype("i1")
            elif ply_type == "uchar": col_dtype = np.dtype("u1")
            elif ply_type == "short": col_dtype = np.dtype("<i2")
            elif ply_type == "ushort":col_dtype = np.dtype("<u2")
            elif ply_type == "int":   col_dtype = np.dtype("<i4")
            elif ply_type == "uint":  col_dtype = np.dtype("<u4")
            elif ply_type == "double":col_dtype = np.dtype("<f8")
            else:
                col_dtype = np.dtype("<f4")
                ply_type = "float"

        col_dtypes.append(col_dtype)
        ply_types.append(ply_type)

    # 字段名：x,y,z + attr3...
    names = ["x", "y", "z"] + [f"attr{j}" for j in range(3, stride)]

    header_lines = [
        "ply",
        "format binary_little_endian 1.0",
        "comment Generated by Inu point-cloud auto-save script",
        f"comment stride={stride} columns: " + " ".join(names),
        f"element vertex {n}",
    ]
    for name, ptype in zip(names, ply_types):
        header_lines.append(f"property {ptype} {name}")
    header_lines.append("end_header")
    header = ("\n".join(header_lines) + "\n").encode("ascii")

    structured = np.empty(n, dtype=list(zip(names, col_dtypes)))
    for j, name in enumerate(names):
        structured[name] = pts2[:, j].astype(col_dtypes[j], copy=False)

    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, "wb") as f:
        f.write(header)
        structured.tofile(f)


# ===================== 键盘事件（只保留 q 退出） =====================
def on_press(key):
    global stop_flag
    try:
        if key == keyboard.KeyCode.from_char('q'):
            stop_flag = True
            print("Stopping capture...")
    except Exception:
        pass


# ===================== 采集 & 自动保存线程 =====================
def capture_and_save_loop(stream):
    global stop_flag, last_stride

    os.makedirs(SAVE_DIR, exist_ok=True)

    frame_count = 0
    saved_count = 0
    file_idx = START_INDEX
    timeout_count = 0

    print(f"[SAVE] Directory: {os.path.abspath(SAVE_DIR)}")
    print(f"[SAVE] Every N frames: {SAVE_EVERY_N_FRAMES}")
    print(f"[SAVE] Max frames: {MAX_SAVE_FRAMES if MAX_SAVE_FRAMES else 'unlimited'}")

    while not stop_flag:
        # max save limit
        if MAX_SAVE_FRAMES and saved_count >= MAX_SAVE_FRAMES:
            print(f"[SAVE] Reached MAX_SAVE_FRAMES={MAX_SAVE_FRAMES}. Stopping...")
            stop_flag = True
            break

        try:
            frame = stream.frame
        except RuntimeError as e:
            msg = str(e)
            if "timed out" in msg or "0x5000033" in msg:
                timeout_count += 1
                print(f"[WARN] GetFrame timeout #{timeout_count}, retry...")
                time.sleep(TIMEOUT_RETRY_SLEEP)
                if timeout_count >= MAX_CONSECUTIVE_TIMEOUTS:
                    raise RuntimeError(f"Too many consecutive timeouts: {timeout_count}") from e
                continue
            else:
                raise

        timeout_count = 0

        if frame is None or frame.num_of_points == 0:
            time.sleep(0.01)
            continue

        pts = np.asarray(frame.data)
        n = frame.num_of_points
        if n <= 0 or pts.size == 0:
            time.sleep(0.01)
            continue

        if pts.size % n != 0:
            print(f"[WARN] size not divisible: size={pts.size}, n={n}")
            continue

        stride = pts.size // n
        last_stride = stride

        # 是否保存这一帧
        should_save = (frame_count % SAVE_EVERY_N_FRAMES == 0)

        if should_save:
            # 保存时才拷贝（避免每帧复制巨大数组）
            pts2 = np.array(pts.reshape(n, stride), copy=True)

            filename = os.path.join(
                SAVE_DIR, FILENAME_FMT.format(prefix=SAVE_PREFIX, idx=file_idx)
            )
            write_ply_binary_all_columns(filename, pts2)

            print(f"[SAVE] {filename}  points={n} stride={stride}")
            saved_count += 1
            file_idx += 1

        frame_count += 1

    print(f"[INFO] Loop ended. frames_seen={frame_count}, files_saved={saved_count}, last_stride={last_stride}")


# ===================== 主程序 =====================
if __name__ == "__main__":
    def _sensor_callback_func(self, sensor: InuSensor, connection_state: ConnectionState, error: Error) -> None:
        print(f"Sensor callback ConnectionState={connection_state} Error={error}")

    print("Starting point cloud auto-save... Press 'q' to stop.")

    sensor, channels_size, hw_information = create_started_sensor(_sensor_callback_func, device_params, '1', '')
    print("Sensor initialized")

    stream = sensor.create_started_stream(StreamType.POINT_CLOUD, None, None)
    print("Point cloud stream initialized")

    time.sleep(1)

    listener = keyboard.Listener(on_press=on_press)
    listener.start()

    t = threading.Thread(target=capture_and_save_loop, args=(stream,), daemon=True)
    t.start()

    # 主线程只负责等待退出
    try:
        while not stop_flag:
            time.sleep(0.1)
    except KeyboardInterrupt:
        stop_flag = True

    listener.stop()

    # 释放资源
    stream.terminate()
    sensor.terminate()
    print("Done.")
